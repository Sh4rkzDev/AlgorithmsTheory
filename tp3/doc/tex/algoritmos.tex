\section{Algoritmos}

A continuación se detallan los códigos y los pasos que se siguieron para llevar a cabo los algoritmos planteados utilizando distintas tecnicas de programacion.

\subsection{Backtracking}

A continuación se detallan el código y los pasos que se siguieron para llevar a cabo el algoritmo planteado utilizando \textbf{\textit{Backtracking}}.

\subsubsection{Obtener las posibles soluciones}

Una vez se obtuvieron todos los subconjuntos de jugadores para cada partido:

\lstinputlisting[language=Python]{code/backtracking.py}

siendo:
\begin{itemize}
    \item $A$: Lista compuesta de $m$ listas, las cuales representan un conjunto de jugadores para jugar un partido.
    \item \texttt{jugadores}: Lista con un subconjunto de jugadores que representan una posible solucion actual.
    \item \texttt{soluciones}: Lista con todos los subconjuntos de jugadores que son soluciones.
    \item \texttt{n}: Numero que indica sobre cual de las $m$ listas estamos trabajando.
    \item \texttt{utilizados}: Diccionario cuyo par \textit{clave-valor} es \textit{jugador-n} donde $n$ representa la enesima-lista en la que fue utilizado el jugador.\footnote{Siendo $n$ el menor valor encontrado hasta el momento}
    \item \texttt{minimo}: El minimo es un numero que representa la longitud del subconjunto mas pequeño que se encuentra en soluciones. (Se utiliza dentro de una lista dado que las listas actuan como punteros)
\end{itemize}

El algoritmo persigue la exploración de diversas soluciones mediante combinaciones, las cuales se ven restringidas mediante condiciones de poda. Este enfoque se implementa con el propósito de evitar la evaluación exhaustiva de todas las posibles combinaciones evitando que se convierta en un algoritmo de \textit{Fuerza Bruta}, optimizando así la eficiencia del proceso.

Estas condiciones de poda son:
\begin{itemize}
	\item En caso de que la longitud de la solución actual sea igual o mayor que la longitud de la solución óptima encontrada hasta el momento, se concluye que la solución actual no mejorará la situación. La igualdad se justifica porque, al estar en esta línea de código, implica que aún quedan listas por recorrer. En estas listas, podría agregarse un elemento más, lo cual invalidaría la condición de optimalidad. En el caso de no agregarlo, no se habría encontrado una solución mejor.
	\item En el caso de que un elemento de la solución actual pertenezca al subconjunto bajo análisis, se concluye que no es necesario explorar soluciones adicionales que involucren elementos de dicho subconjunto. dado que nuestro objetivo es usar la menor cantidad de elementos en la solucion final.
	\item Si un jugador ya fue utilizado en un nivel mas alto del arbol de posibilidades, entonces ya cubrio todas las combinaciones que vengan en niveles inferiores. En consecuencia, si se detecta la presencia de dicho jugador en un nivel menor al que se había identificado previamente, se interrumpe la exploración de nuevas combinaciones con este elemento, dado que su participación ya ha sido exhaustivamente considerada en niveles superiores.
\end{itemize}

En cuanto a la complejidad del algoritmo, este analiza exhaustivamente todas las combinaciones posibles. No obstante, interrumpe el procesamiento de aquellas combinaciones que no conducen a una solución óptima, lo que, en consonancia con la propia naturaleza del enfoque de backtracking, implica una complejidad de ${O}(2^n)$, dada su relación con la exploración de todas las combinaciones posibles. 

\subsubsection{Obtener la solucion optima de todas las ya encontradas}

Para obtener la solucion optima se implementó el siguiente algoritmo:

\lstinputlisting[language=Python]{code/optima.py}

El codigo lo unico que hace una vez imvocada a la funcion es buscar la minima solucion en base a la longitud.


\subsection{Programacion Lineal}





\subsection{Algoritmo Greedy}

Para poder ir al codigo, primero recordemos como funciona un algoritmo Greedy. Los algoritmos Greedy siguen una regla sencilla que les permiten obtener un \textit{óptimo local} según el estado actual del programa, y poder llegar a un \textit{óptimo general} combinando los locales. A su vez presentan desventajas, como por ejemplo que no siempre dan el resultado óptimo, o que demostrar que el resultado es óptimo es difícil. Por otro lado, son intuitivos de pensar y fácil de entender, y suelen ser eficientes.

Ahora bien, nuestra regla sencilla se baso en lo siguiente:
\begin{itemize}
    \item Para cada uno de los elementos, en nuestro caso jugadores, se iterara el resto de subconjuntos, que en este caso seran los pedidos de los demas medios.
    \item Se tomara el jugador que mas medios represente y pueda hacernos quedar bien con ellos. Estos medios ya se desestimaran porque ya habra un jugador que ellos desean ver.
    \item En caso de que la actual iteracion sea de un medio que ya esta considerado ya que uno de sus jugadores fue tomado en cuenta, se continuara sin analizarlo.
\end{itemize}

Esto hara lo mejor posible teniendo en cuenta la informacion actual del programa ya que siempre buscara el mejor jugador que pueda satisfacer la mayor cantidad de medios posibles.

El codigo es el siguiente:

\lstinputlisting[language=Python]{code/greedy.py}

El codigo funciona de la siguiente manera:
\begin{itemize}
    \item \texttt{b}: set de subconjuntos que recibimos. Cada subconjunto representaria los pedidos de los medios.
    \item \texttt{res}: set de resultado, aqui se aniadiran todos los jugadores que deben meterse si o si en el plantel si Scaloni no quiere problemas con ningun medio.
    \item \texttt{considered}: set de medios que se van considerando a medido que aniadimos jugadores a nuestro set de resultado.
    \item Para cada $subset$ se itera sus elementos, que aqui seran los pedidos de los medios y los jugadores que desean ver. Para cada jugador del medio que se esta iterando, se iteran los que quedan por ver, y nos guardaremos los medios que abarcara cada jugador para luego desestimarlos ya que estaran siendo considerados al elegir al jugador que mas abarque medios.
    \item cuando se termina de iterar dicho medio, se agrega todos los medios del jugador que mas abarca al set de medios considerados, asi ahora en adelante esos no se tienen en cuenta para calcular la eficiencia de un jugador al determinar que tanto nos aportara si lo metemos o no.
\end{itemize}

La complejidad de dicho algoritmo es $\mathcal{O}\left(n^2 \times m^2\right)$ siendo $n$ la cantidad de subsets (pedidos de los medios) y $m$ la cantidad de elementos (jugadores) ya que por cada subset se itera cada elemento, y por cada elemento se itera $n-1$ subsets y por cada uno de esos subsets todos sus elementos.