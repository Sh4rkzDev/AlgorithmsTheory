\section{Algoritmo para encontrar la mayor ganancia en los entrenamientos}

A continuación se detallan el código y los pasos que se siguieron para llevar a cabo el algoritmo planteado utilizando \textit{Programación Dinámica}.

\subsection{Obtener el cronograma}

Una vez que se obtuvieron los datos para los entrenamientos y la energía disponible dependiendo la cantidad de días seguidos de haber entrenado, se arma una matriz de tamaño $n \times n$ siendo $n$ la cantidad de días en el cronograma:

\lstinputlisting[language=Python]{code/workout.py}

El algoritmo se basa en crear una matriz de $n \times n$ siendo $n$ la cantidad de dias. ¿Por qué una matriz y no un simple arreglo? En este problema, tenemos que considerar no solo una variable a la hora de buscar los óptimos, sino dos. Una será la ganancia del entrenamiento, y la otra la cantidad de energía que tendremos ese día dependiendo si es el primer día que entrenamos desde el último descanso, o el segundo, etc. Entonces la forma que planteamos es usar la energía para cada día como filas, y la ganancia de cada entrenamiento como las columnas.

A la hora de calcular los óptimos para cada día, se seguirá el siguiente algoritmo:
\begin{itemize}
    \item Si el dia $e_i$ es el primero que se entrena desde un descanso (fila uno), hay que obtener el óptimo del día $e_{i-2}$, ya que el anterior se supone que se descansó.\footnote{Esto solo es válido para los entrenamientos pasados el segundo día.}
    \item Si el día $e_i$ es el segundo que se entrena desde un descanso (fila dos), habrá que sumar a la ganancia del día $e_{i-1}$ la del día actual teniendo en cuenta la energía que se redujo respecto el primer día, pues recordemos 
    \[ s_1 \geq s_2 \geq ... \geq s_n\]
    \item Para el dia $e_i$ la cantidad máxima de posibles entrenamientos es $i$, ya que siempre el óptimo es respecto a los dias descansados como la ganancia de ese entrenamiento, y estos son proporcionales a la cantidad de días, lo que nos resulta en una matriz cuadrada.
\end{itemize}

A su vez, esta forma de resolver el problema nos resultará en una matriz triangular, ya que la cantidad máxima de filas es la cantidad de días y lo mismo con los entrenamientos, pero el entrenamiento del día $e_i$ completara hasta máximo $i$ filas, dejando el resto de las filas hasta $n$ en 0.

Respecto a la complejidad del algoritmo, todas las operaciones que se hacen son constantes, pues acceder a una posición específica de un arreglo, hacer comparaciones, y asignar valores son $\mathcal{O}(1)$. Pero al mismo tiempo, cada una de estas operaciones se realizan $i$ veces para el entrenamiento $e_i$. Y para cada entrenamiento, se realiza $i$ veces para la energía de cada posible situación de los días seguidos entrenados, pues por cada entrenamiento $e_i$ tengo que considerar la ganancia para la energía $s_1, s_2, ..., s_i$, formando así la matriz triangular. Considerando todo esto, la complejidad final del algoritmo es $\mathcal{O}(n \times n) = \mathcal{O}(n^2)$ 


